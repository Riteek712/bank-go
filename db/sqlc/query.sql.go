// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :exec

INSERT INTO accounts (
  owner, balance, currency, created_at
) VALUES (
  $1, $2, $3, $4
)
`

type CreateAccountParams struct {
	Owner     string
	Balance   int64
	Currency  string
	CreatedAt pgtype.Timestamptz
}

// accounts.sql
// Create a new account
func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.Exec(ctx, createAccount,
		arg.Owner,
		arg.Balance,
		arg.Currency,
		arg.CreatedAt,
	)
	return err
}

const createEntry = `-- name: CreateEntry :exec

INSERT INTO entries (
  account_id, amount, created_at
) VALUES (
  $1, $2, $3
)
`

type CreateEntryParams struct {
	AccountID int64
	Amount    int64
	CreatedAt pgtype.Timestamptz
}

// entries.sql
// Create a new entry
func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) error {
	_, err := q.db.Exec(ctx, createEntry, arg.AccountID, arg.Amount, arg.CreatedAt)
	return err
}

const createSession = `-- name: CreateSession :exec

INSERT INTO sessions (
  id, username, refresh_token, user_agent, client_ip, is_blocked, expires_at, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
`

type CreateSessionParams struct {
	ID           pgtype.UUID
	Username     string
	RefreshToken string
	UserAgent    string
	ClientIp     string
	IsBlocked    bool
	ExpiresAt    pgtype.Timestamptz
	CreatedAt    pgtype.Timestamptz
}

// sessions.sql
// Create a new session
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.Exec(ctx, createSession,
		arg.ID,
		arg.Username,
		arg.RefreshToken,
		arg.UserAgent,
		arg.ClientIp,
		arg.IsBlocked,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}

const createTransfer = `-- name: CreateTransfer :exec

INSERT INTO transfers (
  from_account_id, to_account_id, amount, created_at
) VALUES (
  $1, $2, $3, $4
)
`

type CreateTransferParams struct {
	FromAccountID int64
	ToAccountID   int64
	Amount        int64
	CreatedAt     pgtype.Timestamptz
}

// transfers.sql
// Create a new transfer
func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) error {
	_, err := q.db.Exec(ctx, createTransfer,
		arg.FromAccountID,
		arg.ToAccountID,
		arg.Amount,
		arg.CreatedAt,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (
  username, role, hashed_password, full_name, email, is_email_verified, password_changed_at, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
`

type CreateUserParams struct {
	Username          string
	Role              string
	HashedPassword    string
	FullName          string
	Email             string
	IsEmailVerified   bool
	PasswordChangedAt pgtype.Timestamptz
	CreatedAt         pgtype.Timestamptz
}

// Create a new user
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.Username,
		arg.Role,
		arg.HashedPassword,
		arg.FullName,
		arg.Email,
		arg.IsEmailVerified,
		arg.PasswordChangedAt,
		arg.CreatedAt,
	)
	return err
}

const createVerifyEmail = `-- name: CreateVerifyEmail :exec

INSERT INTO verify_emails (
  username, email, secret_code, is_used, created_at, expired_at
) VALUES (
  $1, $2, $3, $4, $5, $6
)
`

type CreateVerifyEmailParams struct {
	Username   string
	Email      string
	SecretCode string
	IsUsed     bool
	CreatedAt  pgtype.Timestamptz
	ExpiredAt  pgtype.Timestamptz
}

// verify_emails.sql
// Create a new verification email
func (q *Queries) CreateVerifyEmail(ctx context.Context, arg CreateVerifyEmailParams) error {
	_, err := q.db.Exec(ctx, createVerifyEmail,
		arg.Username,
		arg.Email,
		arg.SecretCode,
		arg.IsUsed,
		arg.CreatedAt,
		arg.ExpiredAt,
	)
	return err
}

const getAccountByOwner = `-- name: GetAccountByOwner :one
SELECT id, owner, balance, currency, created_at FROM accounts
WHERE owner = $1
LIMIT 1
`

// Get account by owner
func (q *Queries) GetAccountByOwner(ctx context.Context, owner string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByOwner, owner)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Balance,
		&i.Currency,
		&i.CreatedAt,
	)
	return i, err
}

const getEntriesByAccountID = `-- name: GetEntriesByAccountID :many
SELECT id, account_id, amount, created_at FROM entries
WHERE account_id = $1
`

// Get entries by account ID
func (q *Queries) GetEntriesByAccountID(ctx context.Context, accountID int64) ([]Entry, error) {
	rows, err := q.db.Query(ctx, getEntriesByAccountID, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entry
	for rows.Next() {
		var i Entry
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, username, refresh_token, user_agent, client_ip, is_blocked, expires_at, created_at FROM sessions
WHERE id = $1
LIMIT 1
`

// Get session by ID
func (q *Queries) GetSessionByID(ctx context.Context, id pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.RefreshToken,
		&i.UserAgent,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getTransfers = `-- name: GetTransfers :many
SELECT id, from_account_id, to_account_id, amount, created_at FROM transfers
WHERE from_account_id = $1 OR to_account_id = $2
`

type GetTransfersParams struct {
	FromAccountID int64
	ToAccountID   int64
}

// Get transfers by from_account_id and to_account_id
func (q *Queries) GetTransfers(ctx context.Context, arg GetTransfersParams) ([]Transfer, error) {
	rows, err := q.db.Query(ctx, getTransfers, arg.FromAccountID, arg.ToAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.ID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByUsername = `-- name: GetUserByUsername :one

SELECT username, role, hashed_password, full_name, email, is_email_verified, password_changed_at, created_at FROM users
WHERE username = $1
LIMIT 1
`

// users.sql
// Get a user by username
func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Role,
		&i.HashedPassword,
		&i.FullName,
		&i.Email,
		&i.IsEmailVerified,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getVerifyEmailByUsername = `-- name: GetVerifyEmailByUsername :one
SELECT id, username, email, secret_code, is_used, created_at, expired_at FROM verify_emails
WHERE username = $1
LIMIT 1
`

// Get verification email by username
func (q *Queries) GetVerifyEmailByUsername(ctx context.Context, username string) (VerifyEmail, error) {
	row := q.db.QueryRow(ctx, getVerifyEmailByUsername, username)
	var i VerifyEmail
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.SecretCode,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const updateAccountBalance = `-- name: UpdateAccountBalance :exec
UPDATE accounts
SET balance = $1
WHERE id = $2
`

type UpdateAccountBalanceParams struct {
	Balance int64
	ID      int64
}

// Update account balance
func (q *Queries) UpdateAccountBalance(ctx context.Context, arg UpdateAccountBalanceParams) error {
	_, err := q.db.Exec(ctx, updateAccountBalance, arg.Balance, arg.ID)
	return err
}

const updateEmailVerified = `-- name: UpdateEmailVerified :exec
UPDATE users
SET is_email_verified = TRUE
WHERE username = $1
`

// Update user's email verification status
func (q *Queries) UpdateEmailVerified(ctx context.Context, username string) error {
	_, err := q.db.Exec(ctx, updateEmailVerified, username)
	return err
}
